# goit-algo-hw-04

## Sorting algorithms

### Опис завдання

Метою даної роботи є порівняння трьох алгоритмів сортування: **злиттям (Merge Sort)**, **вставками (Insertion Sort)** та **Timsort** (стандартний алгоритм Python). 

Аналіз базується на емпіричних даних, отриманих шляхом вимірювання часу виконання алгоритмів на наборах випадкових даних різного розміру за допомогою модуля `timeit`. Необхідно перевірити теоретичні оцінки складності та пояснити ефективність Timsort.

### Опис алгоритмів

1.  **Сортування вставками (Insertion Sort):**
    * Простий алгоритм, що будує відсортований масив поступово.
    * *Теоретична складність:* $O(n^2)$.
    * Ефективний на дуже малих або майже відсортованих масивах.

2.  **Сортування злиттям (Merge Sort):**
    * Алгоритм "розділяй і володарюй". Рекурсивно ділить масив навпіл і зливає відсортовані частини.
    * *Теоретична складність:* $O(n ⋅ log n)$.
    * Ефективний на великих масивах, але вимагає додаткової пам'яті.

3.  **Timsort (Python `sorted` / `list.sort`):**
    * Гібридний алгоритм, що поєднує сортування вставками та злиттям.
    * *Теоретична складність:* $O(n ⋅ log n)$ у середньому та найгіршому випадках; $O(n)$ у найкращому.
    * Використовує вставки для малих фрагментів (runs), а потім зливає їх.

### Результати тестування (Емпіричні дані)

Нижче наведено час виконання алгоритмів (у секундах) для масивів різного розміру.

| Розмір масиву (N) | Insertion Sort (O(n^2)) | Merge Sort (O(n ⋅ log n)) | Timsort (Hybrid) |
| :--- | :--- | :--- | :--- |
| **100** | 0.000244 | 0.000239 | 0.000011 |
| **1,000** | 0.028697 | 0.002409 | 0.000131 |
| **5,000** | 0.767464 | 0.017847 | 0.000664 |
| **10,000** | *Skipped (>10s)* | 0.041767 | 0.002170 |

### Аналіз та висновки

#### 1. Підтвердження теоретичних оцінок
Емпіричні дані чітко відображають теоретичну складність алгоритмів:
* **Insertion Sort:** Час виконання зростає квадратично. При збільшенні даних у 10 разів (зі 100 до 1000), час зростає більш ніж у 100 разів. Це робить алгоритм непридатним для великих наборів даних.
* **Merge Sort:** Демонструє стабільне зростання часу $O(n ⋅ log n)$, що значно краще за квадратичну залежність на великих масивах.
* **Timsort:** Показує найкращі результати у всіх тестах, значно випереджаючи обидва інші алгоритми.

#### 2. Ефективність Timsort
Timsort виявився найефективнішим з наступних причин:
* **Гібридний підхід:** Він використовує сортування вставками для малих підмасивів (де воно працює швидше завдяки малим накладним витратам) і сортування злиттям для об'єднання цих підмасивів (забезпечуючи ефективність).
* **Адаптивність:** Timsort використовує вже існуючу впорядкованість у даних, що дозволяє йому працювати швидше на реальних даних, ніж "чистому" Merge Sort.
* **Оптимізація реалізації:** Вбудовані функції Python написані на мові C, що дає значний приріст швидкості порівняно з реалізаціями алгоритмів на чистому Python.

#### 3. Загальний висновок
Поєднання механізмів сортування вставками та злиттям робить **Timsort** набагато ефективнішим за чисті версії цих алгоритмів окремо. Саме тому використання вбудованих функцій сортування в Python є найкращою практикою для розробників, оскільки вони забезпечують максимальну продуктивність без необхідності ручної реалізації складних алгоритмів.